package local.domain1;

import gnu.getopt.Getopt;
import org.apache.commons.collections.map.MultiValueMap;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.jsoup.Connection;
import org.jsoup.Jsoup;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.DecimalFormat;
import java.text.Normalizer;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Collector {
    boolean verbose,generateCharts;

    String coreFile = "files/json/core_test.json",baseFile = "files/json/base_selection.json";
    //String coreFile = "files/json/core_selection_long.json",baseFile = "files/json/base_selection_long.json";

    int numberOfRecords,numberOfFiles,numberOfMatches,succeededDownloads,numberOfFIleFields,literalMatches;
    int leaveOnlyNumbersAndLetters, removeMultipleSpaces,replaceNewLinesWithSpaces,removeLeadingAndTrailingSpaces,runid,statusCode;

    String e_literal,e_removeMultipleSpaces,e_leaveOnlyNumbersAndLetters,e_replaceNewLinesWithSpaces,e_removeLeadingAndTrailingSpaces, existingFile;
    String smallestNonMatch,rep,statusMessage,feedback;

    ArrayList<String> allExt,successExt,allUrlDomains,successUrlDomains,matchFieldsRecord;
    ArrayList<String> matchFieldsFile,downloadErrorCodes,TitleIDs,UrlIDs,IdIDs,fieldList;
    MultiValueMap extensionsAndDomains,domainsAndExtensions,successfulExtensionsAndDomains,successfulDomainsAndExtensions,matches;
    HashSet<String> urlAddressList;

    SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss, dd-MM-yyyy");
    Long startTime,finishTime;

    Db db;

    public static void main(String[] args) {
        new Collector(args);
    }

    public Collector(String[] args){
        verbose=false;
        generateCharts =false;
        allExt = new ArrayList();
        successExt = new ArrayList();
        allUrlDomains = new ArrayList();
        successUrlDomains = new ArrayList();
        matchFieldsRecord = new ArrayList();
        matchFieldsFile = new ArrayList();
        downloadErrorCodes = new ArrayList();
        TitleIDs = new ArrayList();
        UrlIDs = new ArrayList();
        IdIDs = new ArrayList();
        fieldList = new ArrayList();
        urlAddressList = new HashSet<String>();
        extensionsAndDomains = new MultiValueMap();
        domainsAndExtensions = new MultiValueMap();
        successfulExtensionsAndDomains = new MultiValueMap();
        successfulDomainsAndExtensions = new MultiValueMap();
        matches = new MultiValueMap();
        sdf.setTimeZone(TimeZone.getTimeZone("GMT+12"));
        sdf.setLenient(false);
        e_literal ="n";
        e_removeMultipleSpaces ="n";
        e_leaveOnlyNumbersAndLetters ="n";
        e_replaceNewLinesWithSpaces ="n";
        e_removeLeadingAndTrailingSpaces ="n";
        db = new Db();

        Getopt g = new Getopt("Collector", args, "vcr:");
        int c;
        String arg = "";
        while ((c = g.getopt()) != -1){
            switch(c){
                case 'v':
                    System.out.print("Verbose mode selected.");
                    verbose = true;
                    break;
                case 'c':
                    generateCharts = true;
                    break;
                case 'r':
                    arg = g.getOptarg();
                    break;
                default:
                    System.out.println("Program syntax: Collector -r <core|base|both> -v -c");
                    System.out.println("-r options (mandatory):");
                    System.out.println("    core: collect and analyze data from http://core.ac.uk/");
                    System.out.println("    base: collect and analyze data from http://base-search.net/");
                    System.out.println("    both: collect and analyze data from both repositories");
                    System.out.println("-v (optional) = verbose mode");
                    System.out.println("-c (optional) = generate charts at the end");
                    break;
            }
        }
        if (arg.equals("core")){
            this.getCoreFiles();
        }else if (arg.equals("base")){
            this.getBaseFiles();
        }else if (arg.equals("both")){
            this.getCoreFiles();
            //this.getBaseFiles();
            //this.validateThis("files/base/1298243.pdf");
            //this.validateThis("files/base/yorkdesigningve's.pdf");
            //this.validateThis("files/base/test.pdf");
            //this.validateThis("files/base/c3dt52279b.pdf");
        }
    }

    private void getBaseFiles() {
        runid = db.getNumberFromDB("runID",0);
        rep = "Base";
        resetCounters();
        String identification="",urlAddress = "";
        JSONObject mainObject;
        JSONArray array;
        startTime = System.currentTimeMillis();
        try {
            System.out.println("\n-------------------- Getting the BASE files...\n");
            System.out.println("Verbose mode: "+verbose);
            System.out.println("Generate charts: "+generateCharts);
            System.out.println("Start time: "+sdf.format(new Date(startTime)));
            mainObject = new JSONObject(new JSONTokener(new FileReader(baseFile)));
            //baseObject = new JSONObject(new JSONTokener(new FileReader(new String (baseFile.getBytes("UTF-8"), Charset.forName("UTF-8")))));
            array = (JSONArray) mainObject.get("records");

            for (int i = 0; i < array.length(); i++) {
                mainObject = (JSONObject) array.getJSONObject(i).get("record");
                //System.out.println("baseobject: "+baseObject.toString());
                if (mainObject.has("title")) {
                    identification = mainObject.getString("title");
                }else if(mainObject.has("description")){
                    identification = mainObject.getString("description");
                }else{
                    identification = mainObject.getJSONArray("subjects").getString(0);
                }
                System.out.println("\n-------------------- Working on record # " +(numberOfRecords+1)+ " from BASE --------------------");
                findUrls(mainObject);
                System.out.println("");
                if (!urlAddressList.isEmpty()){ // download the file(s)...
                    Iterator it = urlAddressList.iterator();
                    for (int u =0;u<urlAddressList.size();u++) {
                        urlAddress = it.next().toString();
                        preDownload(
                                "files/base/",
                                new URL(urlAddress).getHost(),
                                urlAddress.substring(urlAddress.lastIndexOf(".") + 1),
                                urlAddress,
                                fieldList,
                                urlAddress.substring(urlAddress.lastIndexOf("/") + 1),
                                mainObject,
                                identification
                        );
                    }
                } else {
                    preDownload("","none","---","",fieldList,"none",mainObject,identification);
                }
                numberOfRecords++;
                urlAddressList.clear();
                fieldList.clear();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        finishTime = System.currentTimeMillis();
        showSummary();
    }

    private void getCoreFiles() {
        String apiKey = "lWIs56bFaqSZ0cD8PLYdHg3OGUxyXVBK"; // TODO: remove this key when distributing the code
        runid = db.getNumberFromDB("runID", 0);
        rep = "Core";
        resetCounters();
        String jsonline = "";
        JSONObject mainObject;
        JSONArray array;
        String file,ext;
        Object identification = "";
        String urlAddress;
        startTime = System.currentTimeMillis();
        try {
            System.out.println("\n-------------------- Getting the CORE files...\n");
            System.out.println("Verbose mode: " + verbose);
            System.out.println("Generate charts: " + generateCharts);
            System.out.println("Start time: " + sdf.format(new Date(startTime)));
            BufferedReader reader = new BufferedReader(new FileReader(coreFile));
            while ((jsonline = reader.readLine()) != null) { // line (individual 10-record list)
                mainObject = new JSONObject(jsonline);
                array = (JSONArray) mainObject.get("data");
                for (int i = 0; i < array.length(); i++) { // record
                    mainObject = array.getJSONObject(i);
                    fieldList = sortList(mainObject.keys());
                    System.out.println("-------------------- Working on record # " + (numberOfRecords + 1) + " from CORE --------------------\n");
                    findUrls(mainObject);
                    identification = mainObject.getString(fieldList.get(0));
                    urlAddressList.add("https://core.ac.uk:443/api-v2/articles/get/" + identification + "/download/pdf?apiKey=" + apiKey);
                    Iterator it = urlAddressList.iterator();
                    for (int u = 0; u < urlAddressList.size(); u++) {
                        urlAddress = it.next().toString();
                        if (urlAddress.contains("core.ac.uk:443")){
                            file = identification+".pdf";
                            ext = "pdf";
                        }else{
                            file = urlAddress.substring(urlAddress.lastIndexOf("/") + 1);
                            ext = urlAddress.substring(urlAddress.lastIndexOf(".") + 1);
                        }
                        //System.out.println("fieldList.size: "+fieldList.size());
                        preDownload(
                                "files/core/",
                                new URL(urlAddress).getHost(),
                                ext,
                                urlAddress,
                                fieldList,
                                file,
                                mainObject,
                                (String)identification
                        );
                    }
                    numberOfRecords++;
                    urlAddressList.clear();
                    fieldList.clear();
                }
            }
            finishTime = System.currentTimeMillis();
            showSummary();
        }catch(Exception e){
            Logger.getLogger(Collector.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    private void findUrls(JSONObject mainObject) throws JSONException, MalformedURLException {    // find where the URL is in the record...
        String key,innerkey,urlAddress = "";
        Iterator<String> keys = mainObject.keys(),innerkeys;
        Object value;
        while (keys.hasNext()) {
            key = keys.next();
            if (rep.equals("Base")){
                fieldList.add(key);
            }
            value = mainObject.get(key);
            if (value instanceof JSONArray) {
                for(int v=0;v<((JSONArray) value).length();v++) {
                    urlAddress = checkUrl(((JSONArray) value).getString(v),key);
                    if (!urlAddress.equals("")){
                        urlAddressList.add(urlAddress);
                    }
                }
            }else if (value instanceof JSONObject) { // contentProvider
                innerkeys = ((JSONObject) value).keys();
                while (innerkeys.hasNext()){
                    innerkey = innerkeys.next();
                    fieldList.add(innerkey);
                    urlAddress = checkUrl(((JSONObject) value).getString(innerkey),key);
                    if (!urlAddress.equals("")){
                        urlAddressList.add(urlAddress);
                    }
                }
            }else if(value instanceof String){ // title and url
                urlAddress = checkUrl((String) value,key);
                if (!urlAddress.equals("")){
                    urlAddressList.add(urlAddress);
                }
            }
        }
        countIDs(fieldList);
    }

    private String checkUrl(String value, String key) throws MalformedURLException {
        String urlAddress = "";
        Pattern p = Pattern.compile("\\b(https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]",Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(value);
        if (m.find()){  // if the string has a url, change its value to the url's address...
            value=m.group(0);
        }
        String testvalue = value.toLowerCase();
        if ((testvalue.endsWith(".pdf")) ||
                (testvalue.endsWith(".jpg")) ||
                (testvalue.endsWith(".doc")) ||
                (testvalue.endsWith(".docx")) ||
                (testvalue.endsWith(".xml")) ||
                (testvalue.endsWith(".gif")) ||
                (testvalue.endsWith(".tif")) ||
                (testvalue.endsWith(".wav")) ||
                (testvalue.endsWith(".gz")) ||
                (testvalue.endsWith(".xls")) ||
                (testvalue.endsWith(".ppt")) ||
                (testvalue.endsWith(".pptx"))) {
            urlAddress = value;
            System.out.println("Found a file \""+urlAddress+"\" in the \""+key+"\" key");
            String extension = urlAddress.substring(urlAddress.lastIndexOf(".")+1);
            String domain = new URL(urlAddress).getHost();
            allExt.add(extension);
            allUrlDomains.add(domain);
            extensionsAndDomains.put(extension,domain);
            domainsAndExtensions.put(domain,extension);
        }
        return urlAddress;
    }

    private void preDownload(String destPath,String domain,String extension,String urlAddress,ArrayList fieldList,String fileName,JSONObject mainObject,String identification){
        boolean hasFile=false;
        long fileSize = 0;
        String success = "";
        long metaTime = 0;
        long downStartTime = 0;
        long downFinishTime = 0;
        File file = null;
        feedback = "";
        boolean downloadPerformed = false;

        if (!urlAddress.equals("")) {
            System.out.println("Starting download process for url: " + urlAddress+"...");
            allUrlDomains.add(domain);
            allExt.add(extension);
            extensionsAndDomains.put(extension,domain);
            domainsAndExtensions.put(domain,extension);
            Connection.Response conn = null;
            try {    // check if the file is ready to be downloaded...
                conn = Jsoup.connect(urlAddress)
                        .userAgent("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.21 (KHTML, like Gecko) Chrome/19.0.1042.0 Safari/535.21")
                        .timeout(10000)
                        .ignoreContentType(true)
                        .followRedirects(true)
                        .ignoreHttpErrors(true)
                        .execute();
            } catch (Exception e) {}
            try {
                if (conn != null) {  // if the url is available...
                    statusCode = conn.statusCode();
                    statusMessage = conn.statusMessage();
                    downStartTime = System.currentTimeMillis();
                    if (statusCode == 200) {    // if the file is downloadable...
                        String remoteFileLastModDate = conn.headers().get("Last-Modified");
                        if (remoteFileLastModDate == null) { // if the remote file's http head doesn't have a Last-Modified field, download the file anyway (it will overwrite the file if it already exists)
                            System.out.println("Could not determine the last time the remote file was modified. Downloading it anyway...");
                            performDownload(destPath, fileName, urlAddress);
                            System.out.println("Download status message: " + statusMessage+"\n");
                            downloadPerformed = true;
                        } else {
                            System.out.println("Remote file's last modification date: " + remoteFileLastModDate);
                            if (shouldBeDownloaded(new SimpleDateFormat("E, d MMM yyyy HH:mm:ss Z", Locale.ENGLISH).parse(remoteFileLastModDate).getTime() / 1000, destPath, fileName,conn.headers().get("Content-Length"))) {
                                performDownload(destPath, fileName, urlAddress);
                                System.out.println("Download status message: " + statusMessage+"\n");
                                downloadPerformed = true;
                            }
                        }
                    } else {
                        System.out.println("");
                        System.out.println("** Could not download the file! **");
                        System.out.println("Found a " + statusCode + " error when retrieving the file named " + fileName);
                        System.out.println("Failed url: " + urlAddress);
                        System.out.println("Download status message: " + statusMessage+"\n");
                        downloadErrorCodes.add(Integer.toString(statusCode));
                    }
                    downFinishTime = System.currentTimeMillis();
                    if (downloadPerformed){
                        System.out.println("Download duration: " + getDurationString(downFinishTime - downStartTime)+"\n");
                    }
                } else {
                    System.out.println("The url \"" + urlAddress + "\" could not be resolved!");
                }

                file = new File(destPath + fileName);
                if (file.exists()) {
                    if (feedback.equals("valid")) { // if the pre-download validation was valid...
                        success = "y";
                    }else if (validateThis(destPath +fileName).equals("valid")){ // only perform the post-download validation if the pre-download validation was not valid...
                        success = "y";
                    } else {
                        success = "n";
                    }
                } else {
                    this.getFileInfo(destPath + fileName);
                    success = "n";
                    fileSize = 0;
                }

                if (success.equals("y")){
                    fileSize = file.length();
                    metaTime = System.currentTimeMillis();
                    analyzeMetadata(mainObject, destPath + fileName, fieldList, identification);
                    metaTime = System.currentTimeMillis() - metaTime;
                    System.out.println("Comparison duration: " + getDurationString(metaTime)+"\n");
                    succeededDownloads++;
                    successExt.add(extension);
                    successUrlDomains.add(domain);
                    successfulExtensionsAndDomains.put(extension,domain);
                    successfulDomainsAndExtensions.put(domain,extension);
                }
                addToDB("addDownload", new String[]{
                        Integer.toString(numberOfRecords + 1),
                        fileName,
                        urlAddress,
                        String.valueOf(fileSize),
                        domain,
                        String.valueOf(statusCode),
                        statusMessage,
                        success,
                        String.valueOf(downStartTime),
                        String.valueOf(downFinishTime),
                        extension,
                        existingFile
                });
                numberOfFiles++;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            System.out.println("\nThe record named \"" + identification + "\" does not have a file to be downloaded...");
        }
        addToDB("addRecord", new String[]{
                Integer.toString(numberOfRecords + 1),
                fileName,
                urlAddress,
                domain,
                extension,
                String.valueOf(fieldList.size()),
                String.valueOf(numberOfFIleFields),
                String.valueOf(metaTime)
        });
        resetPredownloadFields();
    }

    private void countIDs(ArrayList fieldList){
        String key="";
        for (int f=0;f<fieldList.size();f++){
            key=fieldList.get(f).toString().toLowerCase();
            if (key.contains("title")) {
                TitleIDs.add(key);
            } else if (key.contains("url")) {
                UrlIDs.add(key);
            } else if (key.equalsIgnoreCase("id")) {
                IdIDs.add(key);
            }
        }
    }

    private void performDownload(String destPath,String fileName,String urlAddress){    // perform the actual download...
        try {
            System.out.println("\nDownloading file named \"" + fileName +" from "+ urlAddress+"\"...");
            URL url = new URL(urlAddress);
            InputStream in = url.openStream();
            Files.copy(in, Paths.get(destPath+fileName), StandardCopyOption.REPLACE_EXISTING);
            in.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private boolean shouldBeDownloaded(long httpLastModDate, String destPath, String fileName, String length){
        boolean response = false;
        File file = new File(destPath+fileName);
        System.out.println("");
        if (file.exists()) {
            if (length!=null){
                if (!Long.toString(file.length()).equals(length)){
                    System.out.println("The remote file has a different size ("+length+") than the local one's ("+file.length()+").");
                    response = true;
                }else{
                    if (!validateThis(destPath+fileName).equals("valid")){   // pre-download validation...
                        response = true;
                    }
                }
            }
            System.out.println("The file "+fileName+" has already been downloaded.");
            long fileLastModDate = file.lastModified()/1000;
            if (verbose) {
                System.out.println("last time the remote file was modified (unix format): " + httpLastModDate);
                System.out.println("Last time the local file was modified: " + fileLastModDate);
            }
            if (httpLastModDate>fileLastModDate){
                System.out.println("The remote file is newer than the local one.");
                response = true;
            }else{
                existingFile ="y";
            }
        }else{
            System.out.println("The file "+fileName+" has not been downloaded yet.");
            response = true;
        }
        return response;
    }

    private String validateThis(String filename){
        long startTime = System.currentTimeMillis();
        feedback = "not valid";
        HashMap<String, String> map = new HashMap<String,String>();
        map.put("gif","GIF-hul");
        map.put("gz","GZIP-kb");
        map.put("jpg","JPEG-hul");
        map.put("pdf","PDF-hul");
        map.put("tif","TIFF-hul");
        map.put("wav","WAVE-hul");
        map.put("xml","XML-hul");
        Map.Entry entry;
        Set mapSet = map.entrySet();
        Iterator mapIterator = mapSet.iterator();
        String fileKey = "",fileValue = "",module = "";
        System.out.println("Validating file named: "+filename);
        while (mapIterator.hasNext()) {
            entry = (Map.Entry) mapIterator.next();
            fileKey = (String) entry.getKey();
            fileValue = (String) entry.getValue();
            if (filename.endsWith(fileKey)){
                module = fileValue;
            }
            if (verbose){
                System.out.println("key: "+fileKey);
                System.out.println("value: "+fileValue);
            }
        }
        System.out.println("Using module: "+module);
        if (!module.equals("")) {
            try {
                String command = "jhove.bat -m " + module+" "+filename;
                //System.out.println("command: "+command);
                //Process p = Runtime.getRuntime().exec("jhove.bat -m " + module+" "+filename);
                Process p = Runtime.getRuntime().exec(command);
                p.waitFor(2, TimeUnit.SECONDS);
                BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
                String line = "";
                if (reader.ready()) {
                    while ((line = reader.readLine()) != null) {
                        //System.out.println("line: "+line);
                        if (line.contains("SignatureMatches:")){
                            if (reader.readLine().contains(module)){
                                feedback = "valid";
                            }
                            break;
                        }
                    }
                }
                reader.close();
                p.destroy();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            feedback = "not found";
        }
        System.out.println("Validation duration: "+getDurationString(System.currentTimeMillis()-startTime));
        System.out.println("Status: "+feedback+"\n");
        return feedback;
    }

    private String getDurationString(Long duration){
        String durationString = "";
        long days = (duration / (24 * 60 * 60 * 1000));
        long hours = (duration / (60 * 60 * 1000) % 24);
        long minutes =(duration / (60 * 1000) % 60);
        long seconds = (duration / 1000 % 60);
        long milliseconds = (duration % 1000);
        if (days>0){
            durationString+=Long.toString(days)+" day(s),";
        }
        if (hours>0){
            durationString+=Long.toString(hours)+" hour(s),";
        }
        if (minutes>0){
            durationString+=Long.toString(minutes)+" minute(s),";
        }
        if (seconds>0){
            durationString+=Long.toString(seconds)+" second(s) and ";
        }
        if (milliseconds>0){
            durationString+=Long.toString(milliseconds)+" millisecond(s)";
        }
        return durationString;
    }

    // get the matadata from the file then compare it with the record's using the compareRecord method
    private void analyzeMetadata(JSONObject mainObject, String file, ArrayList fieldList, String title) throws JSONException {
        //verbose = true;
        JSONArray array;
        JSONObject object;
        boolean hasaMatch=false;
        Iterator<String> keys;
        String mainkey="";
        String key="";
        HashMap fileFields = this.getFileInfo(file);
        System.out.println("Comparing the record's metadata with the one from the file named "+file);
        for (int f = 0; f < fieldList.size(); f++) {    // cycle through the record
            mainkey = (String) fieldList.get(f);
            if (verbose) {
                System.out.println("mainkey: "+mainkey);
            }
            if (mainObject.has(mainkey)) {
                if (mainObject.get(mainkey) instanceof JSONObject) {
                    object = mainObject.getJSONObject(mainkey);
                    keys = object.keys();
                    while (keys.hasNext()) {
                        key = keys.next();
                        if (verbose) {
                            System.out.println("key: " + mainkey + " and value: " + object.getString(key));
                        }
                        hasaMatch=compareRecord(mainkey+":"+key, object.getString(key),file, title,fileFields);
                    }
                } else if (mainObject.get(mainkey) instanceof JSONArray) {
                    array = mainObject.getJSONArray(mainkey);
                    if (verbose) {
                        System.out.println("size: "+array.length());
                    }
                    for (int a = 0; a < array.length(); a++) {
                        if (verbose) {
                            System.out.println("key: "+mainkey+" and value: "+array.getString(a));
                        }
                        hasaMatch=compareRecord(mainkey, array.getString(a),file, title,fileFields);
                    }
                }else if(mainObject.get(mainkey) instanceof String){
                    hasaMatch=compareRecord(mainkey, mainObject.getString(mainkey),file, title,fileFields);
                }
            }
        }
        if (!hasaMatch){
            System.out.println("");
            System.out.println("No matches were found.");
        }
        //verbose = false;
    }

    // get a single key and record pair from a record and compare with the metadata of its respective file
    private boolean compareRecord(String recordKey,String recordValue,String filename,String title, HashMap fields){
        Map.Entry entry;
        boolean matchFound=false;
        Set mapSet = fields.entrySet();
        Iterator mapIterator = mapSet.iterator();
        String fileKey = "",fileValue = "",matchReasons = "";
        while (mapIterator.hasNext()){  // each record field is compared to all fields of the file
            entry = (Map.Entry) mapIterator.next();
            fileKey = (String) entry.getKey();
            fileValue = (String) entry.getValue();
            if (verbose) {
                System.out.println("filekey: " + fileKey + " and filevalue: " + fileValue);
                System.out.println("recordKey: " + recordKey + " and recordValue: " + recordValue);
            }
            matchReasons+=findAMatch(recordValue,fileValue,recordValue,"literalMatches");
            matchReasons+=findAMatch(recordValue.replaceAll("\\s+"," "),fileValue.replaceAll("\\s+"," "),recordValue,"removeMultipleSpaces");
            matchReasons+=findAMatch(recordValue.trim(),fileValue.trim(),recordValue,"removeLeadingAndTrailingSpaces");
            matchReasons+=findAMatch(recordValue.replaceAll("\\n"," "),fileValue.replaceAll("\\n"," "),recordValue,"replaceNewLinesWithSpaces");
            matchReasons+=findAMatch(Normalizer.normalize(recordValue, Normalizer.Form.NFD).replaceAll("[^\\p{L}\\p{Nd}]+",""),
                    Normalizer.normalize(fileValue, Normalizer.Form.NFD).replaceAll("[^\\p{L}\\p{Nd}]+",""),recordValue,"leaveOnlyNumbersAndLetters");
            if (!matchReasons.equals("")){
                System.out.println("");
                System.out.println("*** MATCH FOUND ***");
                System.out.println("Key \"" + recordKey + "\" from record titled \"" + title + "\" ");
                System.out.println("matches key \"" + fileKey+"\" from file \""+filename+"\"");
                System.out.println("--- value from record: \""+recordValue+"\"");
                System.out.println("--- value from file: \""+fileValue+"\"");
                System.out.print(matchReasons);
                matchReasons="";
                numberOfMatches++;
                addToDB(
                        "addMatch",
                        new String[]{
                                recordKey,
                                fileKey,
                                recordValue,
                                fileValue,
                                Integer.toString(numberOfRecords+1),
                                filename.replace("files/"+rep.toLowerCase()+"/",""),
                                e_literal,
                                e_removeMultipleSpaces,
                                e_leaveOnlyNumbersAndLetters,
                                e_replaceNewLinesWithSpaces,
                                e_removeLeadingAndTrailingSpaces
                        }
                );
                matchFieldsRecord.add(recordKey.toLowerCase());
                matchFieldsFile.add(fileKey.toLowerCase());
                matchFound = true;
                resetMatchEnums();
            }
        }
        return matchFound;
    }

    private String findAMatch(String value1, String value2, String originalRecordValue,String checkType){
        String matchMessage = "";
        if (checkType.equals("literalMatches")) { // compare the two fields literally
            if (value1.equals(value2)){
                matchMessage="Match found by comparing both literally\n";
                e_literal ="y";
                literalMatches++;
            }else{
                checkSmallestNonMatch(originalRecordValue);
            }
        }else{
            if (value1.equalsIgnoreCase(value2)){
                if(checkType.equals("removeMultipleSpaces")){ // compare the two fields by replacing one or more spaces by a single space in a case insensitive manner
                    matchMessage="Match found by removing multiple spaces\n";
                    e_removeMultipleSpaces ="y";
                    removeMultipleSpaces++;
                }else if(checkType.equals("removeLeadingAndTrailingSpaces")){ // compare the two fields by removing leading and trailing spaces
                    matchMessage="Match found by removing leading and trailing spaces\n";
                    e_removeLeadingAndTrailingSpaces ="y";
                    removeLeadingAndTrailingSpaces++;
                }else if(checkType.equals("replaceNewLinesWithSpaces")){ // compare the two fields by replacing new lines with spaces
                    matchMessage="Match found by replacing new lines with spaces\n";
                    e_replaceNewLinesWithSpaces ="y";
                    replaceNewLinesWithSpaces++;
                }else if(checkType.equals("leaveOnlyNumbersAndLetters")){ // compare the two fields by removing all the non-letters and non-numbers in a case insensitive manner
                    matchMessage="Match found by leaving only numbers and letters on both fields\n";
                    e_leaveOnlyNumbersAndLetters ="y";
                    leaveOnlyNumbersAndLetters++;
                }
            }else{
                checkSmallestNonMatch(originalRecordValue);
            }
        }
        if (!matchMessage.equals("")){
            matches.put(value1,value2);
        }
        return matchMessage;
    }

    private void checkSmallestNonMatch(String recordValue){
        if (recordValue.length()!=0) {
            if (recordValue.length() < smallestNonMatch.length()) {
                smallestNonMatch = recordValue;
            }
        }
    }

    private HashMap getFileInfo(String pdfFile) {
        String command = "";
        Process p;
        String field="";
        String value="";
        HashMap<String, String> map = new HashMap<String,String>();
        try {
            command = "exiftool --*Profile*Blob* --*History* --*Mendeley* --*Property* --*Manifest* --*Page*Image* --Headline "+pdfFile;
            p = Runtime.getRuntime().exec(command);
            p.waitFor();
            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String line = "";
            if (reader.ready()) {
                while ((line = reader.readLine()) != null) {
                    field = line.split(":", 2)[0];
                    value = line.split(":", 2)[1];
                    if (verbose) {
                        System.out.println("field: " + field + " and value: " + value);
                    }
                    map.put(field.replaceAll("\\s+$", ""), value.replaceFirst(" ", ""));
                    numberOfFIleFields++;
                }
            }
            reader.close();
            p.destroy();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return map;
    }

    private ArrayList sortList(Iterator list){ // place the id at the top of the list
        ArrayList al = new ArrayList();
        al.add("id");
        Object obj;
        while (list.hasNext()){
            obj=list.next();
            if (!obj.equals("id")){
                al.add(obj.toString());
            }
        }
        return al;
    }

    private void resetCounters(){
        numberOfRecords = 0;
        numberOfFiles = 0;
        numberOfMatches = 0;
        succeededDownloads = 0;
        leaveOnlyNumbersAndLetters = 0;
        removeMultipleSpaces = 0;
        replaceNewLinesWithSpaces = 0;
        removeLeadingAndTrailingSpaces = 0;
        literalMatches = 0;
        resetPredownloadFields();
        allExt.clear();
        successExt.clear();
        allUrlDomains.clear();
        successUrlDomains.clear();
        extensionsAndDomains.clear();
        domainsAndExtensions.clear();
        successfulExtensionsAndDomains.clear();
        successfulDomainsAndExtensions.clear();
        matches.clear();
        matchFieldsRecord.clear();
        matchFieldsFile.clear();
        downloadErrorCodes.clear();
        TitleIDs.clear();
        UrlIDs.clear();
        IdIDs.clear();
        fieldList.clear();
        urlAddressList.clear();
        resetMatchEnums();

        smallestNonMatch = "";
        for(int s=0;s<1000;s++){
            smallestNonMatch+=" ";
        }
    }

    private void resetPredownloadFields(){
        numberOfFIleFields = 0;
        statusMessage = "FAILED";
        statusCode=0;
        existingFile = "n";
    }

    private void resetMatchEnums(){
        e_literal ="n";
        e_removeMultipleSpaces ="n";
        e_leaveOnlyNumbersAndLetters ="n";
        e_replaceNewLinesWithSpaces ="n";
        e_removeLeadingAndTrailingSpaces ="n";
    }

    private int counter(String subject, String collection){
        int c = 0;
        ArrayList<String> arrayList = new ArrayList();
        if (collection.equals("allExt")){
            arrayList = allExt;
        }else if(collection.equals("successExt")){
            arrayList = successExt;
        }else if(collection.equals("allUrlDomains")){
            arrayList = allUrlDomains;
        }else if(collection.equals("successUrlDomains")){
            arrayList =successUrlDomains;
        }else if(collection.equals("matchFieldsRecord")){
            arrayList = matchFieldsRecord;
        }else if(collection.equals("matchFieldsFile")){
            arrayList = matchFieldsFile;
        }else if(collection.equals("downloadErrorCodes")){
            arrayList = downloadErrorCodes;
        }else if(collection.equals("TitleIDs")){
            arrayList = TitleIDs;
        }else if(collection.equals("UrlIDs")){
            arrayList = UrlIDs;
        }else if(collection.equals("IdIDs")){
            arrayList = IdIDs;
        }
        for (int i = 0; i< arrayList.size(); i++){
            if (arrayList.get(i).equals(subject)){
                c++;
            }
        }
        return c;
    }

    private int successCounter(String subject,String subject2,String collection){
        MultiValueMap map = new MultiValueMap();
        int c = 0;
        if(collection.equals("successfulDomainsAndExtensions")){
            map = successfulDomainsAndExtensions;
        }else if(collection.equals("successfulExtensionsAndDomains")) {
            map = successfulExtensionsAndDomains;
        }
        Object[] keys = map.keySet().toArray();
        Object[] value =null;
        Object key = null;
        for (int k = 0; k< keys.length; k++){
            key = keys[k].toString();
            if (key.equals(subject)) {
                value = map.getCollection(key).toArray();
                for (int v = 0; v < value.length; v++) {
                    if (value[v].toString().equals(subject2)) {
                        c++;
                    }
                }
            }
        }
        return c;
    }
    private void displaySubjects(String checkThis, String subject,String item){ // it also prepares the graph data
        MultiValueMap map = new MultiValueMap();    // MultiValueMaps store repeated keys
        String smap = "";
        String subjectType = "";
        if (subject.equals("extension")) {  // here, the given value (checkThis) has to be an extension
            map = domainsAndExtensions; // domain is the key and the extension is the value
            smap = "successfulDomainsAndExtensions";
            subjectType = "link(s)";
        }else if (subject.equals("domain")){// here, the given value (checkThis) has to be a domain
            map = extensionsAndDomains; // the extension is the key and the domain is the value
            smap = "successfulExtensionsAndDomains";
            subjectType = "files(s)";
        }
        Object[] keys = map.keySet().toArray();
        Object[] value =null;
        Object key = null;
        int counter = 0;
        int successCounter=0;
        for (int i = 0; i< keys.length; i++){
            key = keys[i];
            value = map.getCollection(key).toArray();
            for (int v=0;v<value.length;v++){
                if (value[v].toString().equals(checkThis)){  // compares the array's value with the given one
                    counter++;
                }
            }
            if (counter>0) {
                successCounter = successCounter(key.toString(),checkThis,smap);
                System.out.print("    "+key.toString()+" - "+counter+" "+subjectType+", ");
                System.out.println("being "+successCounter+" successful download(s) and "+(counter-successCounter)+" failure(s)");
            }
            counter=0;
        }
    }

    private void showSummary(){
        System.out.println("");
        System.out.println("######################################################### Summary of findings - "+rep.toUpperCase()+" #########################################################");
        System.out.println("");
        addToDB("addRun",null);
        System.out.println("Start time: "+ sdf.format(startTime));
        System.out.println("Finish time: "+sdf.format(finishTime));
        System.out.println("Download duration: "+getDurationString(finishTime-startTime));
        System.out.println("Total number of "+rep+" records: "+numberOfRecords);
        System.out.println("");
        System.out.println("-------- File information");
        System.out.println("The number of downloaded files ("+ succeededDownloads +") makes "+
                new DecimalFormat("#.00").format(((double) succeededDownloads *100)/(double)numberOfFiles)+
                "% of the total number of "+rep+" download links available ("+numberOfFiles+").");
        System.out.println("");
        System.out.println("Of those links:");
        Object[] uniqueFields = new HashSet<Object>(allExt).toArray();
        int all = 0;
        int success = 0;
        String item = "";
        for (int i=0;i<uniqueFields.length;i++){
            all = counter(uniqueFields[i].toString(),"allExt");
            if (all>0) {
                success = counter(uniqueFields[i].toString(), "successExt");
                System.out.println("");
                item = uniqueFields[i].toString().toUpperCase();
                System.out.println(all + " had the " + item + " extension ("+
                        new DecimalFormat("#.00").format((((double)all*100)/(double)numberOfFiles))+"% of all links), being " + success +" downloaded successfully ("+
                        new DecimalFormat("#.00").format((((double)success*100)/(double) succeededDownloads))+"% of all downloads) which makes a "+
                        new DecimalFormat("#.00").format((((double)success*100)/(double) all))+"% success rate");
                System.out.println("--- The following domains had this extension:");
                displaySubjects(uniqueFields[i].toString(),"extension",item);
            }
        }
        Charts thischart = new Charts();
        if (generateCharts){
            thischart.createChart(
                    "Successful domains per extension - "+rep.toUpperCase(),
                    "Domains",
                    "Successful downloads",
                    thischart.pullChartData("domPerExtPerRun_1",new String[]{Integer.toString(runid)}),
                    finishTime,
                    Integer.toString(runid),
                    0,
                    true
            );
        }
        System.out.println("");
        System.out.println("Extensions from domains:");
        uniqueFields = new HashSet<Object>(allUrlDomains).toArray();
        for (int f=0;f<uniqueFields.length;f++){
            all = counter(uniqueFields[f].toString(),"allUrlDomains");
            if (all>0) {
                success = counter(uniqueFields[f].toString(), "successUrlDomains");
                System.out.println("");
                item = uniqueFields[f].toString();
                System.out.println("\"" + item + "\" counts " + all + " link(s) (" +
                        new DecimalFormat("#.00").format((((double) all * 100) / (double) numberOfFiles)) + "% of all links) and " + success + " download(s) (" +
                        new DecimalFormat("#.00").format((((double) success * 100) / (double) succeededDownloads)) + "% of all downloads) which makes a " +
                        new DecimalFormat("#.00").format((((double) success * 100) / (double) all)) + "% success rate");
                System.out.println("--- This domain had the following extensions:");
                displaySubjects(uniqueFields[f].toString(),"domain",item);
            }
        }
        if (generateCharts){
            thischart.createChart(
                    "Successful extensions per domain - "+rep.toUpperCase(),
                    "Extensions",
                    "Successful downloads",
                    thischart.pullChartData("extPerDomPerRun_1",new String[]{Integer.toString(runid)}),
                    finishTime,
                    Integer.toString(runid),
                    0,
                    true
            );
        }
        System.out.println("");
        System.out.println("Download error codes:");
        displayFieldCounters(downloadErrorCodes,"downloadErrorCodes","error(s)");
        System.out.println("");
        System.out.println("-------- Field information");
        int norf = db.getNumberFromDB("numberOfRecordFields",runid);
        int nom = db.getNumberFromDB("numberOfMatches",runid);
        int noff = db.getNumberFromDB("numberOfFIleFields",runid);
        System.out.println("Number of fields analyzed on "+rep+" records: "+norf);
        System.out.println("Number of fields analyzed on "+rep+" files: "+noff);
        System.out.println("Number of matches found when comparing "+rep+" records with "+rep+" files: "+nom);
        System.out.println("The number of matches ("+nom+") makes "+
                new DecimalFormat("#.00").format((((double)nom*100)/(double)norf))+
                "% of the total number of "+rep+" fields ("+norf+").");
        System.out.println("");
        System.out.println("The smallest non-match field is: "+smallestNonMatch);
        System.out.println("");
        System.out.println("--- Identifiers:");
        displayFieldCounters(TitleIDs,"TitleIDs","title identifiers");
        displayFieldCounters(UrlIDs,"UrlIDs","url identifiers");
        displayFieldCounters(IdIDs,"IdIDs","id identifiers");
        System.out.println("");
        System.out.println("--- Match methods:");
        System.out.println("    By removing multiple spaces: "+ removeMultipleSpaces);
        System.out.println("    By leaving only numbers and letters on both fields: "+leaveOnlyNumbersAndLetters);
        System.out.println("    By replacing new lines with spaces: "+replaceNewLinesWithSpaces);
        System.out.println("    By removing leading and trailing spaces: "+removeLeadingAndTrailingSpaces);
        System.out.println("");
        System.out.println("--- Reasons for the match(es) in the records:");
        displayFieldCounters(matchFieldsRecord,"matchFieldsRecord","match(es)");
        System.out.println("");
        System.out.println("--- Reasons for the match(es) in the files:");
        displayFieldCounters(matchFieldsFile,"matchFieldsFile","match(es)");
        System.out.println("");
        System.out.println("######################################################### End of the Summary - "+rep.toUpperCase()+" ##########################################################");
    }

    private void displayFieldCounters(ArrayList list, String listname, String typemessage){
        Object[] uniqueFields = new HashSet<Object>(list).toArray();
        int all = 0;
        for (int f=0;f<uniqueFields.length;f++){
            all = counter(uniqueFields[f].toString(),listname);
            if (all>0) {
                System.out.println("    "+uniqueFields[f].toString()+" - "+all+" "+typemessage);
                if (listname.endsWith("IDs")){
                    addToDB("addId",new String[]{
                            uniqueFields[f].toString(),
                            Integer.toString(all),
                            typemessage.replace(" identifiers","")
                    });
                }
            }
        }
    }

    private void addToDB(String action, String[] array){
        try{
            java.sql.Connection conn = db.getConn();
            String query = "";
            if (action.equals("addRun")){
                query = "insert into rep_run (" +
                        "id," +
                        "repname," +
                        "startTime," +
                        "finishTime" +
                        ") values ("+
                            runid+",\""+
                            rep.toLowerCase()+"\","+
                            startTime+","+
                            finishTime+
                        ")";
            }else if (action.equals("addRecord")){
                query = "insert into rep_record (" +
                        "runId," +
                        "recordNumber," +
                        "fileName," +
                        "url," +
                        "domname," +
                        "extname," +
                        "numberOfRecordFields," +
                        "numberOfFIleFields," +
                        "analysisDuration" +
                        ") values (" +
                        runid + "," +
                        array[0] + ",\"" +
                        array[1] + "\",\"" +
                        array[2] + "\",\"" +
                        array[3] + "\",\"" +
                        array[4] + "\"," +
                        array[5] + "," +
                        array[6] + "," +
                        array[7] + ")";
            }else if (action.equals("addDownload")){
                query = "insert into rep_download (" +
                        "runId," +
                        "recordNumber," +
                        "fileName," +
                        "url," +
                        "fileSize," +
                        "domname," +
                        "statusCode," +
                        "statusMessage," +
                        "success," +
                        "startTime," +
                        "finishTime," +
                        "extname," +
                        "existingFile" +
                        ") values (" +
                        runid + "," +
                        array[0] + ",\"" +
                        array[1] + "\",\"" +
                        array[2] + "\"," +
                        array[3] + ",\"" +
                        array[4] + "\"," +
                        array[5] + ",\"" +
                        array[6] + "\",\"" +
                        array[7] + "\"," +
                        array[8] + "," +
                        array[9] + ",\"" +
                        array[10] + "\",\"" +
                        array[11] + "\")";
            }else if (action.equals("addMatch")) {
                query = "insert into rep_match (" +
                        "runId," +
                        "recordKey," +
                        "fileKey," +
                        "recordValue," +
                        "fileValue," +
                        "recordNumber," +
                        "fileName," +
                        "literal," +
                        "removeMultipleSpaces," +
                        "leaveOnlyNumbersAndLetters," +
                        "replaceNewLinesWithSpaces," +
                        "removeLeadingAndTrailingSpaces" +
                        ") values (" +
                        runid + ",\"" +
                        array[0] + "\",\"" +
                        array[1] + "\",\"" +
                        array[2] + "\",\"" +
                        array[3] + "\"," +
                        array[4] + ",\"" +
                        array[5] + "\",\"" +
                        array[6] + "\",\"" +
                        array[7] + "\",\"" +
                        array[8] + "\",\"" +
                        array[9] + "\",\"" +
                        array[10] + "\")";
            }else if (action.equals("addId")){
                query = "insert into rep_id (" +
                        "runId," +
                        "idname," +
                        "numFound," +
                        "idType" +
                        ") values (" +
                        runid + ",\"" +
                        array[0] + "\"," +
                        array[1] + ",\"" +
                        array[2] + "\")";
            }
            //System.out.println("query: "+query);
            conn.prepareStatement(query).execute();
            conn.close();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    private void writeToCsv(String rep){
        System.out.println("");
        try {
            Files.write(
                    Paths.get("files/csv/"+rep+".csv"),
                    Arrays.asList("1st line", "2nd line"),
                    Charset.forName("UTF-8")
            );
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    private void getCoreList(){ // used once to download all pages, one by one
        try {
            URL url;
            BufferedReader in;
            PrintWriter writer = new PrintWriter("files/json/core_selection_long.json", "UTF-8");
            for (int i = 50;i<=70;i++) {    // institutions
                System.out.println("---- institution # " + i+" ----");
                for (int p = 1; p <= 100; p++) {    // pages
                    url = new URL("https://core.ac.uk/api-v2/articles/search/repositories.id:%28"+i+"%29?metadata=true&fulltext=false&page=" + p + "&citations=false&similar=false&duplicate=false&urls=true&extractedUrls=false&faithfulMetadata=false&apiKey=lWIs56bFaqSZ0cD8PLYdHg3OGUxyXVBK");
                    in = new BufferedReader(new InputStreamReader(url.openConnection().getInputStream()));
                    System.out.println("page # " + p);
                    writer.println(in.readLine());
                }
            }
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
